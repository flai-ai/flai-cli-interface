# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FlaiCLIInterfaceDialog
                                 A QGIS plugin
 This plugin provides GUI control over FLAI CLI and easy access to Flai's DataHub.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-06-11
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Flai d.o.o
        email                : vid.tk@flai.ai
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os, time, re, platform, sys, importlib
import webbrowser   # python native lib for browser opening links, could use also QDesktopServices.openUrl(QUrl("https://www.example.com"))
import concurrent.futures
import threading
from functools import partial
from datetime  import datetime

from .file_selection_dialog import FileSelectionDialog
from .constants             import *

from qgis.PyQt.QtCore    import Qt, QUrl, pyqtSlot, QTimer, QSettings, QProcess, pyqtSignal, QStandardPaths, QFile, QIODevice, QJsonDocument, QJsonParseError
from qgis.PyQt.QtGui     import QDesktopServices, QPixmap, QFont, QColor
from qgis.PyQt.QtWidgets import QDialog, QCheckBox, QVBoxLayout, QPushButton, QLabel, QGraphicsOpacityEffect, QMessageBox, QPlainTextEdit, QHBoxLayout
from qgis.PyQt           import uic, QtWidgets
from qgis.core           import QgsProject, QgsLayerTreeLayer, QgsVectorLayer, QgsRasterLayer, QgsPointCloudLayer, QgsPointCloudCategory, QgsPointCloudClassifiedRenderer


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'flai_cli_interface_dialog_base.ui'))



class FlaiCLIInterfaceDialog(QtWidgets.QDialog, FORM_CLASS):
    value_changed_for_welcome_warning = pyqtSignal(bool)


    def __init__(self, iface, parent=None):
        """Constructor."""
        super(FlaiCLIInterfaceDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        self.iface = iface
        self.setupUi(self)

        # disabling resizing for now
        self.setSizeGripEnabled(False)           # hide the sizeâ€grip in the corner
        self.setFixedSize(self.size())           # lock the dialog to its current size

        # create a new QFont for message box text and its buttons
        self._font_inside_msg_box = QFont(self.label_wasCLIFound.font())

        self.label_logoFlai.setText('')
        self.label_logoFlai.setPixmap(QPixmap(":/plugins/flai_cli_interface/media/icon_with_CLI_2.png"))      # this path has to be the same as in the resources.qrc

        self.label_datahub_background.setText('')
        self.label_datahub_background.setPixmap(QPixmap(":/plugins/flai_cli_interface/media/datahub_background.png"))    # this path has to be the same as in the resources.qrc

        # create and install an opacity effect
        effect = QGraphicsOpacityEffect(self.label_datahub_background)
        effect.setOpacity(0.075)        # 0.0 = fully transparent, 1.0 = fully opaque
        self.label_datahub_background.setGraphicsEffect(effect)

        # important variables
        plugin_dir            = os.path.dirname(__file__)                      # this file lives in .../plugins/flai-cli-interface/
        self._default_cli_dir = os.path.join(plugin_dir, 'flai-utils', 'cli')        
        os.makedirs(self._default_cli_dir, exist_ok=True)

        self._current_system = platform.system()
        
        # we need to save this variables only if we are on Windows
        self._windows_flai_access_token = ''
        self._windows_flai_host         = ''

        self._cfg_path = os.path.join(plugin_dir, '.settings.ini')                   # create a QSettings that reads/writes program settings, to make life easier for user
        self._settings = QSettings(self._cfg_path, QSettings.IniFormat)
        
        self._is_show_welcome_warning_disabled = False
        self._loading_and_setting_show_welcome_warning_from_settings()

        self._flai_sdk_executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)     # for async sdk calls (making a bit smoother experience); also do not use ProcessPoolExecutor - can cause problems on Windows
        self._running_flow_process = QProcess()

        self.flow_templates = None
        self._selected_flow_template_id = ''

        self._original_readers, self._original_writers = [], []           # data types
        self._output_manager_paths, self._input_manager_paths = {}, {}    # dictionary paths
        
        self._first_time_showing_automatically_generated_output_paths = True

        self._processing_start_time = None
        self._data_displaying_behavior = -1
        self._output_paths = {}

        self._whitespace_regex = re.compile(r"\s")

        self._default_input_pc_semantic_schema = []
        self._output_pc_semantic_schema = []

        # hidden variables, only modified by setters and getters
        self._is_flow_template_selected = False  # checks for button that shows command  
        self._are_output_paths_ok = False        # all have to be True for it to be enabled
        self._are_input_paths_ok = False
        self._are_measurement_units_ok = False

        # do not forget about automatic scaling !!!!!
        # make program automagically remember last location when user loads it, save it as .flai_cli_interface_settings
        # warning about closing the gui but not killing the running process, it will still run in background (only button Reset and entry from dropdown Hard reset will kill running flow)

        # setting up "Getting started" tab, this vars do not need to be in `reset_ui_and_variables(...)` function
        self.pshBtn_reset.setText('Reset')
        self.pshBtn_findFile.clicked.connect(self._select_cli)
        self.pshBtn_reset.clicked.connect(self._reset_ui_and_variables)
        self.pshBtn_downloadFile.clicked.connect(self._get_cli_link)

        # setting up "Processing" tab, this vars do not need to be in `reset_ui_and_variables(...)` function
        self._reset_flow_template_combobox()
        self.cmbBx_flowTemplate.currentIndexChanged.connect(self._on_flow_template_changed)
        self._on_flow_template_changed(self.cmbBx_flowTemplate.currentIndex())

        self.pshBtn_createOrEdit.clicked.connect(self._on_create_or_edit_flow_template)
        
        self.pshBtn_selectInput.clicked.connect(
            partial(self._get_file_paths, self.pshBtn_selectInput)
        )
        self.pshBtn_selectOutput.clicked.connect(
            partial(self._get_file_paths, self.pshBtn_selectOutput)
        )

        self.cmbBx_measurementUnits.addItems([
            "",                 # default at index 0
            "meter",
            "foot",
            "us-foot",
        ])
        self.cmbBx_measurementUnits.currentIndexChanged.connect(self._on_measurement_unit_changed)
        self._on_measurement_unit_changed(self.cmbBx_measurementUnits.currentIndex())

        self.radioBtn_noDisplay.toggled.connect(self._set_displaying_input_output_behavior)
        self.radioBtn_displayOnFinish.toggled.connect(self._set_displaying_input_output_behavior)
        self.radioBtn_diplayAsProcessingHappens.toggled.connect(self._set_displaying_input_output_behavior)
        
        self.radioBtn_diplayAsProcessingHappens.setEnabled(False)   # disable for now, problematic because file listener can be faster than CLI can finish creating an output file (there can be missing data and file will not load correctly)

        self.pshBtn_showCommand.clicked.connect(self._show_executable_command)
        self.pshBtn_runFlow.clicked.connect(self._run_flow)

        self.warningLabel_flowTemplate.setStyleSheet("color: #D1AE00;") # #F0D25A
        self.warningLabel_inputFolder.setStyleSheet("color: #D1AE00;")
        self.warningLabel_outputFolder.setStyleSheet("color: #D1AE00;")
        self.warningLabel_measurementUnits.setStyleSheet("color: #D1AE00;")

        # setting up "DataHub" tab, this vars do not need to be in `reset_ui_and_variables(...)` function
        self.pshBtn_redirectToWebDataHub.clicked.connect(
            lambda: webbrowser.open("https://hub.flai.ai/#/?utm_source=qgis&utm_medium=qgis-flai-plugin&utm_campaigne=flai-hub.flai.ai", new=1)       
        )

        self._reset_ui_and_variables()
        self._choose_focus_tab()

        # install flai-sdk if missing
        try:
            self._load_flai_sdk()
        except ImportError:
            # --- build the one-and-only dialog ---
            self._installDialog = QDialog(self)
            self._installDialog.setWindowTitle("Flai CLI interface - missing dependency")
            # 4) make it bigger up front
            self._installDialog.resize(600, 250)

            # 2) apply font-size to everything in one go
            self._installDialog.setStyleSheet(
                f"* {{ font-size: {TEXT_SIZE_INSIDE_MSG_BOX}pt; }}"
            )
            layout = QVBoxLayout(self._installDialog)

            # 1) Prompt label
            self._promptLabel = QLabel(
                "The Python package <b>flai-sdk</b> is not installed.",
                self._installDialog
            )
            layout.addWidget(self._promptLabel)

            # 2) Buttons
            btn_layout = QHBoxLayout()
            self._installBtn = QPushButton("Install flai-sdk", self._installDialog)
            self._cancelBtn  = QPushButton("Close plugin",   self._installDialog)
            btn_layout.addWidget(self._installBtn)
            btn_layout.addWidget(self._cancelBtn)
            layout.addLayout(btn_layout)

            # 3) Hidden log console
            self._installer_log = QPlainTextEdit(self._installDialog)
            self._installer_log.setReadOnly(True)
            self._installer_log.hide()
            layout.addWidget(self._installer_log)

            # Connections
            self._installBtn.clicked.connect(self._on_install_clicked)
            self._cancelBtn.clicked.connect(self._installDialog.reject)

            self._installDialog.exec_()


    def _on_install_clicked(self):
        # swap UI into â€œinstallingâ€ mode
        self._promptLabel.setText("Installing flai-sdkâ€¦ please wait.")
        self._installBtn.setEnabled(False)
        self._cancelBtn.setEnabled(False)
        self._installer_log.show()

        # clear any stale caches so import will work after install
        importlib.invalidate_caches()

        # launch pip
        prog = sys.executable
        # args = ["-m", "pip", "install", "flai-sdk"]                                                                                                             # production PyPI
        args = ["-m", "pip", "install", "--index-url", "https://test.pypi.org/simple/", "--extra-index-url", "https://pypi.org/simple", "flai-sdk==0.0.3"]    # testing PyPI
        full_cmd = f"{prog} {' '.join(args)}"

        self._running_flow_process.setProgram(prog)
        self._running_flow_process.setArguments(args)

        self._installer_log.appendHtml(f"<b>Running command</b>: {full_cmd}<br>")

        self._running_flow_process.readyReadStandardOutput.connect(self._installer_log_append_stdout)
        self._running_flow_process.readyReadStandardError.connect(self._installer_log_append_stderr)
        self._running_flow_process.finished.connect(self._on_install_finished)
        self._running_flow_process.start()


    def _installer_log_append_stdout(self):
        out = bytes(self._running_flow_process.readAllStandardOutput()).decode()
        # 3) collapse multiple newlines into one
        cleaned = re.sub(r'\n+', '\n', out).rstrip('\n')
        self._installer_log.appendPlainText(cleaned)


    def _installer_log_append_stderr(self):
        err = bytes(self._running_flow_process.readAllStandardError()).decode()
        cleaned = re.sub(r'\n+', '\n', err).rstrip('\n')
        self._installer_log.appendHtml(f'<span style="color:red;">{cleaned}</span>')


    def _on_install_finished(self, exit_code, exit_status):
        if exit_code == 0:
            self._promptLabel.setText("âœ” flai-sdk installed successfully. No need to restart QGIS.")
        else:
            self._promptLabel.setText(
                f"âœ˜ Installation failed (exit code {exit_code}). "
            )
        # repurpose Cancel into a Close button now that weâ€™re done
        self._cancelBtn.setEnabled(True)
        self._cancelBtn.setText("Close")

        # finally, if success, load the SDK so the rest of your plugin can run
        if exit_code == 0:
            self._load_flai_sdk()


    def _load_flai_sdk(self):
        # if you just installed it, clear import caches
        importlib.invalidate_caches()

        # import the bits you needâ€¦
        from flai_sdk.api.organizations               import FlaiOrganization
        from flai_sdk.api.flow_templates              import FlaiFlowTemplates
        from flai_sdk.api.flows                       import FlaiFlows
        from flai_sdk.models.flow_templates           import CreateLocalFlow
        from flai_sdk.api.semantic_definition_schemas import SemanticDefinitionSchemasModel
        from flai_sdk.api.ai_models                   import FlaiAiModel

        # stash them as attributes
        self.FlaiOrganization               = FlaiOrganization
        self.FlaiFlowTemplates              = FlaiFlowTemplates
        self.FlaiFlows                      = FlaiFlows
        self.CreateLocalFlow                = CreateLocalFlow
        self.SemanticDefinitionSchemasModel = SemanticDefinitionSchemasModel
        self.FlaiAiModel                    = FlaiAiModel

    
    def show(self):
        """Override the show method to display a message box before showing the dialog."""
        # show a message box before showing the dialog
        if not self._is_show_welcome_warning_disabled:
            # create a custom message box (QDialog)
            msg_box = QDialog(self)
            msg_box.setWindowTitle("Important information about usage")

            # create a vertical layout to hold the message and checkbox
            layout = QVBoxLayout()

            # set label for the message
            message = "In order for plugin to work as expected, it needs connection to the internet\nto gether data from our servers (to get data for flows)."
            message_label = QLabel(message, msg_box)
            layout.addWidget(message_label)

            # create the checkbox
            self.checkbox = QCheckBox("Do not show again", msg_box)
            self.checkbox.setChecked(self._is_show_welcome_warning_disabled)
            layout.addWidget(self.checkbox)

            # create OK button
            ok_button = QPushButton("OK", msg_box)
            ok_button.clicked.connect(msg_box.accept)  # Accept the dialog on OK button click
            layout.addWidget(ok_button)

            msg_box.setLayout(layout)

            # unify font
            msg_box.setFont(self._font_inside_msg_box)

            msg_box.exec_()

            # after the dialog is closed, we can check the state of the checkbox
            checkbox_value = self.checkbox.isChecked()

            if self._is_show_welcome_warning_disabled != checkbox_value:
                self._settings.setValue('is-welcome-warning-disabled', int(checkbox_value))
                self._is_show_welcome_warning_disabled = checkbox_value

        # Call the base class's show method to actually display the dialog
        super().show()

    
    def stop_threaded_processes(self):          # somehow this does not work correctly, fix it
        return
    
        # stop the QProcess + its entire tree
        if hasattr(self, "_running_flow_process"):
            proc = self._running_flow_process
            if proc.state() != QProcess.NotRunning:
                try:
                    # first, try the graceful Qt shutdown
                    proc.terminate()
                    proc.waitForFinished(2000)
                finally:
                    # then forcibly kill everything
                    pid = int(proc.processId() or proc.pid())
                    parent = psutil.Process(pid)
                    for child in parent.children(recursive=True):
                        child.kill()
                    parent.kill()

            self._running_flow_process = QProcess()

        # then your ThreadPoolExecutor shutdown as before
        if hasattr(self, "_flai_sdk_executor"):
            try:
                self._flai_sdk_executor.shutdown(
                    wait=False,
                    cancel_futures=True
                )
            except TypeError:
                self._flai_sdk_executor.shutdown(wait=False)
            # note: this wonâ€™t forcibly kill alreadyâ€running threads;
            # tasks themselves must cooperate if you need immediate cancellation.

            self._flai_sdk_executor = concurrent.futures.ThreadPoolExecutor(max_workers=1)


    def show_generic_sdk_warning(self, 
                                 message: str,
                                 title: str = "flai-sdk encountered a problem"
                                 ) -> QMessageBox.StandardButton:
        box = QMessageBox(self)                     # parent=this dialog
        box.setIcon(QMessageBox.Warning)            # yellow warning icon
        box.setWindowTitle(title)
        box.setText(message)
        box.setStandardButtons(QMessageBox.Ok)
        box.setDefaultButton(QMessageBox.Ok)
        box.setWindowModality(Qt.WindowModal)       # only block this dialog
        return box.exec_()


    def _choose_focus_tab(self):
        # if processing is disabled, show getting starter tab
        if not self.tab_processing.isEnabled():
            self.tabWidget.setCurrentIndex(
                self.tabWidget.indexOf(self.tab_gettingStarted)
            )
        # otherwise processing tab
        else:
            self.tabWidget.setCurrentIndex(
                self.tabWidget.indexOf(self.tab_processing)
            )


    def _reset_ui_and_variables(self):
        self._cli_path    = ''
        self._cli_version = ''
        self._org_name    = ''

        self._output_manager_paths, self._input_manager_paths = {}, {}
        self._original_readers, self._original_writers = [], []
        
        self._first_time_showing_automatically_generated_output_paths = True
        
        self.is_flow_template_selected = False
        self.are_output_paths_ok = False
        self.are_input_paths_ok = False
        self.are_measurement_units_ok = False

        self.label_flowSummary.clear()

        # setting up "Getting started" tab
        self.label_wasCLIFound.setText(
            '<strong>Flai CLI not found.</strong><br>' +
            'The Processing tab is disabled because the Flai CLI isnâ€™t installed or configured on this system.<br><br>' +
            'Please install the Flai CLI and then click the button below to locate its executable.'
        )
        self.label_aboutCLIVersion.setText('')
        self.label_aboutYourOrganization.setText('')

        self.pshBtn_findFile.setEnabled(True)           # this two might be set to true if user has successfully activated CLI before clicking "reset" button
        self.pshBtn_downloadFile.setEnabled(True)

        # setting up "Processing" tab
        self.tab_processing.setEnabled(False)           # until user is not loged in, this will be disabled
        
        self.cmbBx_flowTemplate.setCurrentIndex(0)      # setting default value for flow template
        self.pshBtn_createOrEdit.setText("Create")      # and setting correct string to button next to flow template GUI object
        
        self.cmbBx_measurementUnits.setCurrentIndex(0)  # setting default value for mesurement units
        
        if self._settings.contains('measurement-unit'):  # preload_measurement unit from settings file
            saved_measurement_unit = self._settings.value('measurement-unit')

            idx = self.cmbBx_measurementUnits.findText(
                saved_measurement_unit, 
                Qt.MatchExactly
            )

            # if we found it set it as current index
            if idx != -1:
                self.cmbBx_measurementUnits.setCurrentIndex(idx)
                self.are_measurement_units_ok = True

        self._clean_variables_of_processing_tab()
        self._disable_buttons_and_clean_warnings_on_processing_tab()
        self._get_displaying_input_and_output_behavior()
        # self.stop_threaded_processes()


    def _set_displaying_input_output_behavior(self):
        saving_type = ''

        if self.radioBtn_noDisplay.isChecked():
            saving_type = DATA_DISPLAYING_BEHAVIOR_NON
        elif self.radioBtn_displayOnFinish.isChecked():
            saving_type = DATA_DISPLAYING_BEHAVIOR_ON_FINISH
        elif self.radioBtn_diplayAsProcessingHappens.isChecked():
            saving_type = DATA_DISPLAYING_BEHAVIOR_REALTIME

        self._settings.setValue('displaying-input-and-output-behavior', saving_type)


    def _get_displaying_input_and_output_behavior(self):
        if self._settings.contains('displaying-input-and-output-behavior'):
            saved_displaying_input_and_output_behavior = self._settings.value('displaying-input-and-output-behavior')

            if saved_displaying_input_and_output_behavior == DATA_DISPLAYING_BEHAVIOR_NON:
                self.radioBtn_noDisplay.setChecked(True)

            elif saved_displaying_input_and_output_behavior == DATA_DISPLAYING_BEHAVIOR_ON_FINISH:
                self.radioBtn_displayOnFinish.setChecked(True)

            elif saved_displaying_input_and_output_behavior == DATA_DISPLAYING_BEHAVIOR_REALTIME:
                self.radioBtn_diplayAsProcessingHappens.setChecked(True)

        else:
            self._set_displaying_input_output_behavior()  # by default a value on one of the radiobuttons will be set


    def _reset_flow_template_combobox(self):
        self.cmbBx_flowTemplate.clear()                       # nuke all items
        self.cmbBx_flowTemplate.addItem("Non selected")       # back to default
        self.cmbBx_flowTemplate.setCurrentIndex(0)            # make sure it is selected
        self.flow_templates_cmbBx_mapping = {
            0: {'title': self.cmbBx_flowTemplate.currentText(), 'id': 'null'}
        }

    # this might not be the best solution, but it will do for now
    @property
    def is_flow_template_selected(self): 
        return self._is_flow_template_selected

    @is_flow_template_selected.setter
    def is_flow_template_selected(self, val: bool):
        self._is_flow_template_selected = bool(val)
        self._update_show_command_button()


    @property
    def are_output_paths_ok(self): 
        return self._are_output_paths_ok

    @are_output_paths_ok.setter
    def are_output_paths_ok(self, val: bool):
        self._are_output_paths_ok = bool(val)
        self._update_show_command_button()


    @property
    def are_input_paths_ok(self): 
        return self._are_input_paths_ok

    @are_input_paths_ok.setter
    def are_input_paths_ok(self, val: bool):
        self._are_input_paths_ok = bool(val)
        self._update_show_command_button()


    @property
    def are_measurement_units_ok(self): 
        return self._are_measurement_units_ok

    @are_measurement_units_ok.setter
    def are_measurement_units_ok(self, val: bool):
        self._are_measurement_units_ok = bool(val)
        self._update_show_command_button()



######################
### PROCESSING tab ###
######################

    def _get_file_paths(self, button_object_name):
        window_title = ''

        # minor settings
        if button_object_name == self.pshBtn_selectInput:
            window_title = 'Select inputs'
            required_types = self._original_readers # ['vector_1', 'point_cloud_2', 'vector_3', 'raster_4']
        elif button_object_name == self.pshBtn_selectOutput:
            window_title = 'Select outputs'
            required_types = self._original_writers
        else:
            print('Hold your horses, this should not happen')

        # show file manager window
        dialog = FileSelectionDialog(
            parent            = self,
            window_title      = window_title,
            given_types       = required_types, 
            font_reference    = self._font_inside_msg_box,
            btn_reference     = self.pshBtn_reset,
            remebered_paths   = self._input_manager_paths if button_object_name == self.pshBtn_selectInput else self._output_manager_paths,
            is_output_manager = True if button_object_name == self.pshBtn_selectOutput else False
        )

        dialog.exec_()

        # check if user did not successfully set input / ouput folders
        if button_object_name == self.pshBtn_selectInput:
            self._input_manager_paths = dialog.selected_paths()
            empty_paths_count = sum(1 for files in self._input_manager_paths.values() if not files)

        elif button_object_name == self.pshBtn_selectOutput:
            self._output_manager_paths = dialog.selected_paths()
            empty_paths_count = sum(1 for files in self._output_manager_paths.values() if not files)
        
        # clearing warnings
        if empty_paths_count == 0:

            if button_object_name == self.pshBtn_selectInput:
                self.warningLabel_inputFolder.setText('')
                self.are_input_paths_ok = True

            elif button_object_name == self.pshBtn_selectOutput:
                self.warningLabel_outputFolder.setText('')
                self.are_output_paths_ok = True
        
        # setting warrnings
        else:
            if button_object_name == self.pshBtn_selectInput:
                self.warningLabel_inputFolder.setText(f'There are {empty_paths_count} empty inputs fields !')
                self.are_input_paths_ok = False

            elif button_object_name == self.pshBtn_selectOutput:
                self.warningLabel_outputFolder.setText(f'There are {empty_paths_count} empty outputs fields !')
                self.are_output_paths_ok = False


    @pyqtSlot(bool)
    def _update_show_command_button(self, _=None):
        # we ignore the boolean payload â€“ we only care about the four attrs
        enable_button_if_all_true = all((
            self._is_flow_template_selected, 
            self._are_output_paths_ok, 
            self._are_input_paths_ok, 
            self._are_measurement_units_ok
        ))
        self.pshBtn_showCommand.setEnabled(enable_button_if_all_true)

        if enable_button_if_all_true:

            chosen_template = self.flow_templates_cmbBx_mapping[self.cmbBx_flowTemplate.currentIndex()]
            local_flow_creator = self.CreateLocalFlow()

            future = self._flai_sdk_executor.submit(
                self.FlaiFlowTemplates().convert_template_to_local_flow,
                create_local_flow_status = local_flow_creator,
                flow_template_id         = chosen_template['id']
            )

            # wait for slow call to finish
            try:
                raw = future.result(timeout=TIMEOUT_TIME_IN_SECONDS)
                self.flow_id_with_local_io = raw["flow_id"] 
            except concurrent.futures.TimeoutError:
                # still running after TIMEOUT_TIME_IN_SECONDS â†’ cancel & fallback
                future.cancel()
                self.show_generic_sdk_warning(message=TIMEOUT_ERROR)
                return
            except Exception as e:
                self.show_generic_sdk_warning(message=GENERAL_ERROR + f"{str(e)}")
                return

            # add local_ if it does not already exist
            self._local_reader = [
                item if item.startswith('local_') else 'local_' + item
                for item in self._original_readers
            ]
            self._local_writer = [     
                item if item.startswith('local_') else 'local_' + item
                for item in self._original_writers
            ]

            # for PC we will use our semantic schema 
            if any('point_cloud' in item for item in self._original_writers):

                detected_type = ''
                detected_id = ''

                for node in self._selected_flow_template_info['flow_nodes']:

                    if POSSIBLE_NODE_KEY_SCHEMA_ID in node['options']:
                        detected_id = node['options'][POSSIBLE_NODE_KEY_SCHEMA_ID]
                        detected_type = POSSIBLE_NODE_KEY_SCHEMA_ID

                    elif POSSIBLE_NODE_KEY_MODEL_ID in node['options']:
                        detected_id = node['options'][POSSIBLE_NODE_KEY_MODEL_ID]
                        detected_type = POSSIBLE_NODE_KEY_MODEL_ID


                if detected_type == POSSIBLE_NODE_KEY_MODEL_ID:
                    future = self._flai_sdk_executor.submit(
                        self.FlaiAiModel().get_semantic_definitions,
                        model_id = detected_id,
                    )

                    # wait for slow call to finish
                    try:
                        semantic_schema = future.result(timeout=TIMEOUT_TIME_IN_SECONDS)
                        self._output_pc_semantic_schema = self._parse_semantic_schema(semantic_schema)
                    except concurrent.futures.TimeoutError:
                        # still running after TIMEOUT_TIME_IN_SECONDS â†’ cancel & fallback
                        future.cancel()
                        self.show_generic_sdk_warning(message=TIMEOUT_ERROR)
                        return
                    except Exception as e:
                        self.show_generic_sdk_warning(message=GENERAL_ERROR + f"{str(e)}")
                        return

                elif detected_type == POSSIBLE_NODE_KEY_SCHEMA_ID:
                    # get output schema
                    future = self._flai_sdk_executor.submit(
                        self.SemanticDefinitionSchemasModel().get_semantic_definitions,
                        semantic_definition_schema_id = detected_id
                    )

                    # wait for slow call to finish
                    try:
                        semantic_schema = future.result(timeout=TIMEOUT_TIME_IN_SECONDS)
                        self._output_pc_semantic_schema = self._parse_semantic_schema(semantic_schema)
                    except concurrent.futures.TimeoutError:
                        # still running after TIMEOUT_TIME_IN_SECONDS s â†’ cancel & fallback
                        future.cancel()
                        self.show_generic_sdk_warning(message=TIMEOUT_ERROR)
                        return
                    except Exception as e:
                        self.show_generic_sdk_warning(message=GENERAL_ERROR + f"{str(e)}")
                        return


    def _disable_buttons_and_clean_warnings_on_processing_tab(self):
        for b in (self.pshBtn_selectInput, self.pshBtn_selectOutput):
            b.setEnabled(False)

        self.cmbBx_measurementUnits.setEnabled(False)    # we will only show it when all data from processing tab is populated

        # we also clean all warnings that appeared
        for l in (self.warningLabel_flowTemplate, 
                  self.warningLabel_inputFolder, 
                  self.warningLabel_outputFolder, 
                  self.warningLabel_measurementUnits):
            l.setText('') 


    def _clean_variables_of_processing_tab(self):
        # reset input and output path managers
        self.are_output_paths_ok = False
        self.are_input_paths_ok  = False

        # dictionary paths
        self._output_manager_paths, self._input_manager_paths = {}, {}

        # data types
        self._original_readers, self._original_writers = [], []
         

    @pyqtSlot(int)
    def _on_flow_template_changed(self, index: int):
        """
        Handles both:
        1. Toggling Create/Edit button text based on whether
           the user picked â€œNon selectedâ€ (index 0) or something else.
        2. Enabling/disabling the other three buttons and updating
           the warning label whenever the selection changes.
        """
        self._clean_variables_of_processing_tab()
        text = self.cmbBx_flowTemplate.currentText()

        # update button next to flow template lineEdit (Create vs. Edit)
        if text != "Non selected":
            self.pshBtn_createOrEdit.setText("Edit")
        else:
            self.pshBtn_createOrEdit.setText("Create")

        is_not_default = (index > 0)

        # fetch data with sdk about the selected flow
        if is_not_default:
            self._selected_flow_template_id = self.flow_templates_cmbBx_mapping[index]['id']
            status = self._get_data_from_selected_flow(self._selected_flow_template_id)
            
            # did we got an error when fetching data?
            if not self.is_flow_template_selected:
                msg = QtWidgets.QMessageBox(self)
                msg.setWindowTitle(f"Error getting flow template data")
                msg.setText(f'{status}\n\nReseting back to empty flow template. Please try again or select different template.')
                msg.setStandardButtons(QtWidgets.QMessageBox.Ok)

                msg.setFont(self._font_inside_msg_box)
                for btn in msg.buttons():
                    btn.setFont(self._font_inside_msg_box)

                msg.exec_()

                # reseting combobox back to default value
                self.cmbBx_flowTemplate.setCurrentIndex(0)
                self.pshBtn_createOrEdit.setText("Create")
                return

        else:
            self._selected_flow_template_id = ''
            self.is_flow_template_selected = False

        # enable/disable the three action buttons and a combobox
        for btn in (self.pshBtn_selectInput,
                    self.pshBtn_selectOutput):
            btn.setEnabled(is_not_default)

        self.cmbBx_measurementUnits.setEnabled(is_not_default) 

        # warning label
        if is_not_default:
            if self._first_time_showing_automatically_generated_output_paths:
                self.warningLabel_outputFolder.setText(OUTPUT_PATH_MANAGER_DEFAULT_VALUE_MESSAGE)
                self._first_time_showing_automatically_generated_output_paths = False

            self._automatically_populate_output_manager()
            self.are_output_paths_ok = True
        
        else:
            self.warningLabel_outputFolder.clear()
            self.are_output_paths_ok = False


    def _get_data_from_selected_flow(self, id):
        flai = self.FlaiFlows()
        future = self._flai_sdk_executor.submit(
            flai.get_flow,
            flow_id   = id,
            get_nodes = True
        )

        # wait for slow call to finish
        try:
            self._selected_flow_template_info = future.result(timeout=TIMEOUT_TIME_IN_SECONDS)

            flow_nodes = self._selected_flow_template_info.get("flow_nodes", [])
            self._original_readers, self._original_writers = [], []

            for item in flow_nodes:
                if isinstance(item, dict):
                    flow_node_key = item.get("flow_node_key", "")
                    if isinstance(flow_node_key, str) and "reader" in flow_node_key:
                        self._original_readers.append(flow_node_key)
                    elif isinstance(flow_node_key, str) and "writer" in flow_node_key:
                        self._original_writers.append(flow_node_key)
            
            self.warningLabel_flowTemplate.setText('')
            self.is_flow_template_selected = True
            return ''
        
        except concurrent.futures.TimeoutError:
            # still running after TIMEOUT_TIME_IN_SECONDS â†’ cancel & fallback
            future.cancel()
            self.show_generic_sdk_warning(message=TIMEOUT_ERROR)
            return
        
        except Exception as e:
            self.show_generic_sdk_warning(message=GENERAL_ERROR + f"{str(e)}")
            return  

    
    def _automatically_populate_output_manager(self):
        base_dir = os.path.join(self._default_cli_dir, 'outputs', DATETIME_PLACEHOLDER)
        line_edits_text = []

        for writer in self._original_writers:
            full_path = os.path.join(base_dir, writer)
            line_edits_text.append(full_path)

        self._output_manager_paths = { i: line_edits_text[i] for i in range(len(line_edits_text)) } 


    def _on_create_or_edit_flow_template(self):
        
        if "Edit" == self.pshBtn_createOrEdit.text():
            field_text = (
                'Plugin will now open a new browser window where you will be able to edit chosen flow. '
                '\n\nDo not forget to save the flow otherwise plugin will not be able to get updated flow.'
                '\n\nOnce satisfied with the change click on the button "Fetch updates" which will '
                'update plugin with the latest data for selected flow template.'
            )
            url = (
                "https://app.flai.ai/#/admin/pages:flows/"
                f"{self._selected_flow_template_id}/edit?"
                "utm_source=qgis&utm_medium=qgis-flai-plugin&utm_campaigne=flai-pages:flows"
            )

        elif "Create" == self.pshBtn_createOrEdit.text():
            field_text = (
                'Plugin open link to our App where you can create a new project called "QGIS plugin" '
                'where you will be able to create and edit flow templates.'
                '\n\nOnce satisfied with the new flow click on the button "Fetch updates" which will '
                'update plugin with the latest data for all flow templates.'
            )
            url = (
                "https://app.flai.ai/#/admin/pages:projects/?"
                "utm_source=qgis&utm_medium=qgis-flai-plugin&utm_campaigne=pages:projects"
            )

        msg = QtWidgets.QMessageBox(self)
        msg.setWindowTitle(f"{self.pshBtn_createOrEdit.text()} flow template")
        msg.setText(field_text)

        # add a custom â€œFetch updatesâ€ button
        msg.addButton("Fetch updates", QtWidgets.QMessageBox.AcceptRole)

        msg.setFont(self._font_inside_msg_box)
        for btn in msg.buttons():
            btn.setFont(self._font_inside_msg_box)

        # schedule URL to open in 3 seconds
        QTimer.singleShot(3000, lambda: webbrowser.open(url, new=1))

        msg.exec_()

        # reset processing variables so that we dont keep old data
        self._clean_variables_of_processing_tab()

        # we update all data related to flows
        if "Create" == self.pshBtn_createOrEdit.text():
            self._reset_flow_template_combobox()     # including UI/UX
            self._populate_flow_template_combobox()

        elif "Edit" == self.pshBtn_createOrEdit.text():
            self._get_data_from_selected_flow(self._selected_flow_template_id)

        # automatically populate output path manager
        self._automatically_populate_output_manager()
        self.are_output_paths_ok = True

        self.warningLabel_inputFolder.setText("Update was fetched, please reselect inputs")
        self.warningLabel_outputFolder.setText("Update was fetched, you might need to reselect outputs")


    @pyqtSlot(int)
    def _on_measurement_unit_changed(self, index: int):
        # if not default, user selected unit, which is ok
        if index == 0:
            self.are_measurement_units_ok = False
        else:
            self.are_measurement_units_ok = True
            self.warningLabel_measurementUnits.setText('')
            self._settings.setValue('measurement-unit', self.cmbBx_measurementUnits.currentText())

            
    def _show_executable_command(self):
        command_with_args = self._get_executable_command()[0]

        # if value contains any whitespace, wrap it in doubleâ€quotes
        program_location = f'"{command_with_args[0]}"' if self._whitespace_regex.search(command_with_args[0]) else command_with_args[0]
        
        # windows specific command
        if self._current_system == SYSTEM_WINDOWS:
            program_location = (
                'wsl \\\n'                                      +
                f'      {self._windows_flai_access_token} \\\n' +
                f'      {self._windows_flai_host} \\\n'         +
                f'      {command_with_args[0]}'
            )

        # first line: the program
        lines = [ f'{program_location} \\' ]

        # every subsequent pair: flag + value
        for flag, val in zip(command_with_args[1::2], command_with_args[2::2]):
            arg = f'"{val}"' if self._whitespace_regex.search(val) else val    # if value contains any whitespace, wrap it in doubleâ€quotes
            lines.append(f'      {flag} {arg} \\')
        
        # strip the trailing backslash from the last line
        lines[-1] = lines[-1].rstrip(" \\")
        shown_command = "\n".join(lines)

        msg = QtWidgets.QMessageBox(self)
        msg.setIcon(QtWidgets.QMessageBox.Information)
        msg.setWindowTitle("Command to be executed")
        msg.setText(shown_command)
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)

        msg.setFont(self._font_inside_msg_box)
        for btn in msg.buttons():
            btn.setFont(self._font_inside_msg_box)

        msg.exec_()


    def _get_executable_command(self):
        # parse string DATETIME_PLACEHOLDER if in self.output_manager_paths
        current_datetime = datetime.now()
        str_current_datetime = current_datetime.strftime("%Y.%m.%d - %H.%M.%S") # cannot use %H:%M:%S, otherwise windows complains

        # needed for later processing, cleanup of DATETIME_PLACEHOLDER
        local_output_type_and_folder = {
            local_io: folder.replace(DATETIME_PLACEHOLDER, str_current_datetime)
            for local_io, folder in zip(self._local_writer, list(self._output_manager_paths.values()))
        }

        # needed for later processing, copying of paths
        local_input_type_and_files = {
            local_key: folder
            for local_key, folder in zip(self._local_reader, self._input_manager_paths.values())
        }

        # keep only path to a single folder for each reader (instead of item paths)
        input_folder = []
        for lst in local_input_type_and_files.values():
            input_folder.append(os.path.dirname(lst[0]))
        
        command = [
            f'{self._cli_path}',
            '--flow_id',     str(self.flow_id_with_local_io),
            '--length_unit', self.cmbBx_measurementUnits.currentText(),
        ]

        # add reader flags + values
        for rdr_cmd, val in zip(self._local_reader, input_folder):
            command.extend([f'--{rdr_cmd}', f'{val}'])

        local_output = list(local_output_type_and_folder.items())

        # add all but last writer
        for wrtr_cmd, val in local_output[:-1]:
            command.extend([f'--{wrtr_cmd}', f'{val}'])

        # add last writer
        wrtr_cmd, val = local_output[-1]
        command.extend([f'--{wrtr_cmd}', f'{val}'])

        # on windows paths paths will not be ok for wsl, we do a little bit of parsing
        if self._current_system == SYSTEM_WINDOWS:
            command = [self._parse_windows_path(arg) for arg in command]

        return command, current_datetime, local_input_type_and_files, local_output_type_and_folder


    def _parse_windows_path(self, path):
        # normalize *any* backslashes, for example `\\\\wsl.localhost\\Ubuntu\\home\\alice\\file.txt`
        if '\\' in path:
            # 1) Leading \\â€¦  â†’ //
            #    - r"^\\\\+"            â†’ match two or more backslashes at the start
            #    - replace with "//"
            # 2) Any remaining \ â†’ /
            path = re.sub(r"^\\\\+", "//", path).replace("\\", "/")

        path_located_inside_wsl_pattern = re.compile(r"^//wsl[^/]+/[^/]+(/.*)$")
        # ^//wsl    â†’ only if the string starts with //wsl
        # [^/]+/    â†’ match the rest of the server name (e.g. .localhost or IP) plus a slash
        # [^/]+     â†’ consume the distro name (Ubuntu, Debian, etc.)
        # (/.*)$    â†’ capture the slash plus everything after (our â€œrealâ€ path)
        m = path_located_inside_wsl_pattern.match(path)
        if m:
            path = m.group(1)

        windows_drive_pattern = re.compile(r'^([A-Za-z]):/(.*)$')
        # ^([A-Za-z])  â†’ capture one ASCII letter (drive letter Aâ€“Z or aâ€“z), sometime it could be lower case (redundant but just in case)
        # :/           â†’ literal colon then forwardâ€slash
        # (.*)$        â†’ capture the rest of the string (zero or more characters)
        m = windows_drive_pattern.match(path)
        if m:
            drive = m.group(1).lower()
            rest  = m.group(2)
            path  = f"/mnt/{drive}/{rest}"

        return path


    def _run_flow(self):
        is_everthing_set_correctly = True

        if not self.is_flow_template_selected or self._selected_flow_template_id == '':
            self.warningLabel_flowTemplate.setText('Please select flow template.')
            is_everthing_set_correctly = False

        if not self.are_input_paths_ok or self._input_manager_paths == {}:
            self.warningLabel_inputFolder.setText('Please select input folders.')
            is_everthing_set_correctly = False

        if not self.are_output_paths_ok or self._output_manager_paths == {}:
            self.warningLabel_outputFolder.setText('Please select output folders.')
            is_everthing_set_correctly = False

        if not self.are_measurement_units_ok or self.cmbBx_measurementUnits.currentIndex() == 0:
            self.warningLabel_measurementUnits.setText('Please select measurement units.')
            is_everthing_set_correctly = False

        if not is_everthing_set_correctly:
            return

        # getting behavior of our vizualizer
        if self.radioBtn_noDisplay.isChecked():
            self._data_displaying_behavior = 0
        elif self.radioBtn_displayOnFinish.isChecked():
            self._data_displaying_behavior = 1
        elif self.radioBtn_diplayAsProcessingHappens.isChecked():
            self._data_displaying_behavior = 2
        
        msg = QtWidgets.QMessageBox(self)
        msg.setIcon(QtWidgets.QMessageBox.Warning)
        msg.setWindowTitle("Confirming action")
        msg.setText(
            "Before we run the given command, make sure everything is set as expected flow-wise "
            "since costs can occur on your side." \
            "\n\n" \
            "TIPS AND TRICKS: On tab Logs you can see what is happening. At bottom right corner you can see lastest line output from CLI."
        )
        # remove any default buttons:
        msg.setStandardButtons(QtWidgets.QMessageBox.NoButton)

        # add your two custom buttons with appropriate roles:
        btn_start = msg.addButton("Start processing", QtWidgets.QMessageBox.AcceptRole)
        btn_back  = msg.addButton("Take me back",  QtWidgets.QMessageBox.RejectRole)

        msg.setFont(self._font_inside_msg_box)
        for btn in msg.buttons():
            btn.setFont(self._font_inside_msg_box)

        msg.exec_()

        if msg.clickedButton() == btn_start:

            # disabling UI so that it cannot be pressed while flow is executing
            self.cmbBx_flowTemplate.setEnabled(False)
            self.pshBtn_createOrEdit.setEnabled(False)
            self.pshBtn_selectInput.setEnabled(False)
            self.pshBtn_selectOutput.setEnabled(False)
            self.cmbBx_measurementUnits.setEnabled(False)
            self.groupBox.setEnabled(False)

            # force immediate update otherwise disabling of UI will not happen before executing the code below
            QtWidgets.QApplication.processEvents()

            # parsing and creating output folders
            self._executing_command,     \
            self._processing_start_time, \
            self._local_input_type_and_files, self._local_output_type_and_folder = self._get_executable_command()

            self._create_folders_from_args(self._executing_command)

            # setting up windows specific command
            if self._current_system == SYSTEM_WINDOWS:
                self.executing_command = [
                    'wsl', 
                    self._windows_flai_access_token, 
                    self._windows_flai_host
                ] + self.executing_command

            # create the layerâ€tree structure, where paths / files will be grouped
            # for option where we do not display anything we do not need to be calls this
            if self._data_displaying_behavior != 0:
                self._setup_layer_tree()

            # load files as they are generated
            if self._data_displaying_behavior == 2:
                # load all inputs right away
                self._load_input_layers()

                # start watching each writer folder for newly-created files
                self._reset_output_helper_dictonary()

                # had problems with QFileSystemWatcher() (with and without moveToThread), this solution worked (not most elegant because of time polling)
                self._output_folder_watcher_poll_stop,  \
                self._output_folder_watcher_poll_thread = self._start_polling_output_folders_watcher(
                    paths    = list(self._local_output_type_and_folder.values()),
                    callback = self._on_directory_changed,
                    interval = OUTPUT_FOLDER_WATCHER_POOLING_RATE_IN_SEC
                )

            parsed_cmd = ''

            for arg in self._executing_command:
                string_arg = f'"{arg}"' if self._whitespace_regex.search(arg) else arg
                parsed_cmd += string_arg + ' '

            # we add few new lines to make output more readable
            if not self.plainTextEdit_logs_processing.document().isEmpty():
                self.plainTextEdit_logs_processing.appendPlainText('\n\n')

            # self.plainTextEdit_logs_processing.appendPlainText(f'Running command: {parsed_cmd}\n')
            self.plainTextEdit_logs_processing.appendHtml(f'<b>Running command:</b> {parsed_cmd}<br>')
            self.label_flowSummary.setText('Launching CLI...')
            
            # use QProcess for running CLI
            self._proc = QProcess(self)
            # merge stderr into stdout
            self._proc.setProcessChannelMode(QProcess.MergedChannels)
            # whenever there is new data, append it to the text widget
            self._proc.readyReadStandardOutput.connect(self._read_output)
            self._proc.finished.connect(self._on_finished)  # this is the last thing that will happen when CLI stops

            # start the external command
            program, *args = self._executing_command
            self._proc.start(program, args)


    def _start_polling_output_folders_watcher(self, paths, callback, interval=1.0):
        """
        paths:    iterable of directory paths
        callback: fn(dirpath) â€” e.g. self._on_directory_changed
        interval: seconds between polls
        returns:  (stop_event, thread)
        """
        stop_event = threading.Event()

        def _poll_loop():
            while not stop_event.is_set():
                for p in paths:
                    callback(p)
                time.sleep(interval)

        t = threading.Thread(target=_poll_loop, daemon=True)
        t.start()
        return stop_event, t
    

    def _read_output(self):
        data = self._proc.readAllStandardOutput()
        text = bytes(data).decode('utf-8', errors='replace')

        # sometimes we could get None in text (not clear why) - can be a single CLI line output which has multiple line breaks
        for line in text.splitlines():
            if line.strip() == "None":
                continue

            self.plainTextEdit_logs_processing.appendPlainText(line)
            self.label_flowSummary.setText(line)


    def _on_finished(self, exitCode, exitStatus):
        out = f"\n Process finished with exit code {exitCode}"
        # out += ' (' + f'âŒ' if exitCode != 0 else f'âœ…' + ')'
        self.plainTextEdit_logs_processing.appendPlainText(out)

        # load files when flow finishes
        if self._data_displaying_behavior == 1:
            if exitCode == 0:                   # if CLI returned error, we will not be looking for output; might be bug here
                # load all inputs
                self._load_input_layers()

                # load all outputs
                self._reset_output_helper_dictonary()
                for folder_paths in list(self._local_output_type_and_folder.values()):
                    self._on_directory_changed(folder_paths)

        elif self._data_displaying_behavior == 2:
            self._output_folder_watcher_poll_stop.set()
            self._output_folder_watcher_poll_thread.join()

        # reenabling back what was disabled
        self.cmbBx_flowTemplate.setEnabled(True)
        self.pshBtn_createOrEdit.setEnabled(True)
        self.pshBtn_selectInput.setEnabled(True)
        self.pshBtn_selectOutput.setEnabled(True)
        self.cmbBx_measurementUnits.setEnabled(True)
        self.groupBox.setEnabled(True)

        self.label_flowSummary.setText('processing ended (Ë¶áµ” áµ• áµ”Ë¶)')
        QTimer.singleShot(5000, lambda: self.label_flowSummary.clear()) # in ms, non blocking

        # force immediate update just in case
        QtWidgets.QApplication.processEvents()


    def _create_folders_from_args(self, args):
        """
        Process command-line arguments to create folders next to 'writer' arguments.
        """
        # Loop through each argument
        i = 1   # first arg will always be CLI-exe-name thus skipping it
        while i < len(args):

            # Check if the argument contains "writer"
            if "writer" in args[i]:
                folder_name = args[i + 1]

                # Create the folder recursively
                try:
                    os.makedirs(folder_name, exist_ok=True)
                except Exception as e:
                    self.show_generic_sdk_warning(message=f"Error creating folder {folder_name}: {str(e)}", title="Problem with creation of a folder")
                # Skip the next argument as it's the folder name
                i += 2
                continue

            i += 1
        return


    def _get_paths_from_command(self, searched_string):
        # skip the program name, then slice into flag/value pairs
        arg_val_map = {
            flag.lstrip('-'): val
            for flag, val in zip(self._executing_command[1::2], self._executing_command[2::2])
            if searched_string in flag
        }

        return arg_val_map
    

    def _safe_name(self, flag):
        # remove leading dashes, replace other dashes with underscores
        return flag.lstrip('-').replace('-', '_')


    def _get_or_create_group(self, parent, name):
        g = parent.findGroup(name)
        return g if g else parent.addGroup(name)


    def _setup_layer_tree(self):
        """Ensure top-level 'input' & 'output' and one subgroup per flag."""
        root = QgsProject.instance().layerTreeRoot()
        self.grp_in  = self._get_or_create_group(root, 'input')
        self.grp_out = self._get_or_create_group(root, 'output')

        # make one subgroup under input per readerâ€flag
        for flag in self._local_input_type_and_files:
            self._get_or_create_group(self.grp_in, self._safe_name(flag))

        # make one subgroup under output per writerâ€flag
        for flag in self._local_output_type_and_folder:
            self._get_or_create_group(self.grp_out, self._safe_name(flag))


    def _create_layer(self, path, path_type_arg='writer'):
        """Pick the right Qgs*Layer by extension."""
        bn = os.path.basename(path)
        ext = bn.lower()

        if ext.endswith(('.shp', '.gpkg', '.geojson')):
            return QgsVectorLayer(path, bn, 'ogr')
        
        if ext.endswith(('.tif','.tiff', '.jp2', '.jp2000')):
            return QgsRasterLayer(path, bn, 'gdal')
        
        if ext.endswith(('.las','.laz', '.copc.laz')):
            # create the pointâ€cloud layer without loading any default style
            # opts = QgsPointCloudLayer.LayerOptions()      # tune this to get the same behavior as drag and drop .la? in QGIS?
            # # opts.loadDefaultStyle = False

            # if ext.endswith(('.copc.laz')):
            #     opts.skipIndexGeneration = True

            layer = QgsPointCloudLayer(path, bn, 'pdal') # , opts

            renderer = layer.renderer()
            if not isinstance(renderer, QgsPointCloudClassifiedRenderer):
                # no classified renderer yet? make one and attach it
                renderer = QgsPointCloudClassifiedRenderer("Classification")
                layer.setRenderer(renderer)

            current_schema = self._default_input_pc_semantic_schema if 'reader' in path_type_arg else self._output_pc_semantic_schema
            categories = []

            # convert current_schema to QgsPointCloudCategory
            for entry in current_schema:
                if entry[SEMANTIC_DEFINITION_VALUE_FIELD] == 'DEFAULT':
                    continue

                r, g, b, a = entry[SEMANTIC_DEFINITION_COLOR_FIELD]

                categories.append( 
                    QgsPointCloudCategory(
                        int(   entry[SEMANTIC_DEFINITION_VALUE_FIELD]),
                        color = QColor.fromRgbF(r, g, b, a),
                        label = str(   entry[SEMANTIC_DEFINITION_LABEL_FIELD])
                    )
                )

            # build a classified renderer on the 'Classification' attribute and add it to layer
            # 4. Swap in only your new categories
            renderer.setAttribute("Classification")            # make sure we're on the right field
            renderer.setCategories(categories)                 # replaces just the Classification classes

            # 5. Refresh
            layer.triggerRepaint()
            return layer
        
        return None


    def _insert_layer_node(self, layer, group):
        """Add layer to project (hidden from root) and into our tree group."""
        QgsProject.instance().addMapLayer(layer, addToLegend=False)
        node = QgsLayerTreeLayer(layer)
        group.addChildNode(node)


    def _load_input_layers(self):
        """Load all pre-existing reader files into 'input' â†’ flag groups."""
        for flag, paths in self._local_input_type_and_files.items():
            grp = self.grp_in.findGroup(self._safe_name(flag))
            for p in paths:
                layer = self._create_layer(p, 'reader')
                if layer and layer.isValid():
                    self._insert_layer_node(layer, grp)
                else:
                    self._report_error(f"Failed to load input {p}")


    def _reset_output_helper_dictonary(self):
        self._output_paths = {}
        for key in self._local_output_type_and_folder:
            self._output_paths[key] = []


    def _on_directory_changed(self, dirpath):
        """Called whenever any watched dir is modified."""
        # figure out which flag this dir belongs to
        flag = next(
            (f for f, d in self._local_output_type_and_folder.items() if d == dirpath),
            None
        )
        if not flag:
            return

        grp = self.grp_out.findGroup(self._safe_name(flag))
        dirpath = dirpath if self._current_system != SYSTEM_WINDOWS else dirpath.replace("\\", "/")
        
        # time.sleep(2.0) # quick and dirty workaround when (realtime) file listener is faster than CLI finishing making a file
                          # but will not work for large file
                          # maybe try using synhronization (e.g. semaphores, mutex) from CLI (making endpoint which can tell when file is not locked or not)
                          # and maybe replace this kind of file listener with synhronization listener (can check lock status)

        for fn in os.listdir(dirpath):
            full = dirpath + os.sep + fn

            # skip if already recorded
            if full in self._output_paths[flag]:
                continue
            # only accept files newer than time user started CLI
            try:
                mtime = datetime.fromtimestamp(os.path.getmtime(full))
            except OSError:
                continue
            if mtime >= self._processing_start_time:
                self._output_paths[flag].append(full)
                layer = self._create_layer(full, flag)
                if layer and layer.isValid():
                    self._insert_layer_node(layer, grp)
                else:
                    self._report_error(f"Failed to load output {full}")


    def _report_error(self, msg):
        if self.iface:
            self.iface.messageBar().pushMessage("Error", msg, level=3)
        else:
            print(msg)



###########################
### GETTING STARTED tab ###
###########################

    def _select_cli(self):
        # get path of user's "installed" CLI
        # something is off !!!!
        if self._settings.contains('cli-path'):
            file_path = self._settings.value('cli-path')
        else:
            file_path, _ = QtWidgets.QFileDialog.getOpenFileName(
                self,
                "Select flai-cli executable",
                self._default_cli_dir,
                "All Files (*)"
            )
            if not file_path:
                return  # user cancelled

        version, status = self._get_cli_version(file_path)

        # if anything was wrong with CLI selection, display error
        if status != '':
            msg = QtWidgets.QMessageBox(self)
            msg.setIcon(QtWidgets.QMessageBox.Critical)
            msg.setWindowTitle("Error")
            msg.setText(status)
            msg.setStandardButtons(QtWidgets.QMessageBox.Ok)

            msg.setFont(self._font_inside_msg_box)
            for btn in msg.buttons():
                btn.setFont(self._font_inside_msg_box)

            msg.exec_()
            return

        # store in instance
        self._cli_path = file_path
        self._cli_version = version

        self._settings.setValue('cli-path', self._cli_path)

        # updating "Getting started" tab
        # kick off the slow call in a separate process
        future = self._flai_sdk_executor.submit(
            self.FlaiOrganization().get_organization_name_and_address    # if you get stuck here, you are missing $HOME/.flai file or you have no internet
        )

        # inform the user about successful selection of CLI
        msg = QtWidgets.QMessageBox(self)
        msg.setIcon(QtWidgets.QMessageBox.Information)
        msg.setWindowTitle("Flai CLI detected")
        msg.setText('CLI program successfully selected.\n\nProgram might seem stuck for a few second. It needs to fetch required data for to be able to use it.\n\nClick OK to proceed.')
        msg.setStandardButtons(QtWidgets.QMessageBox.Ok)

        msg.setFont(self._font_inside_msg_box)
        for btn in msg.buttons():
            btn.setFont(self._font_inside_msg_box)

        msg.exec_()

        # wait for slow call to finish
        try:
            self._org_name = future.result(timeout=TIMEOUT_TIME_IN_SECONDS)
        except concurrent.futures.TimeoutError:
            # still running after TIMEOUT_TIME_IN_SECONDS s â†’ cancel & fallback
            future.cancel()
            self._org_name = 'CONNECTION ERROR'
            self.show_generic_sdk_warning(message=TIMEOUT_ERROR)
        except Exception as e:
            self.show_generic_sdk_warning(message=GENERAL_ERROR + f"{str(e)}")
            self._org_name = 'GENERAL_ERROR ENCOUNTERED'
        
        # parsing data from .flai on user's home path, since WSL cannot access it
        if self._current_system == SYSTEM_WINDOWS:
            home = QStandardPaths.writableLocation(QStandardPaths.HomeLocation)
            file_path = home + '/.flai'

            f = QFile(file_path)
            if not f.open(QIODevice.ReadOnly | QIODevice.Text):
                print("Cannot open file:", f.errorString())
            else:
                raw = f.readAll()
                doc = QJsonDocument.fromJson(raw, _err := QJsonParseError())
                if _err.error != QJsonParseError.NoError:
                    print("JSON parse error:", _err.errorString())
                else:
                    obj = doc.object()
                    self._windows_flai_access_token = f"FLAI_ACCESS_TOKEN='{obj['flai_access_token'].toString()}'"
                    self._windows_flai_host = f"FLAI_HOST='{obj['flai_host'].toString()}'"

                    if '|' in self._windows_flai_access_token:
                        self._windows_flai_access_token = self._windows_flai_access_token.replace('|', r'\|')

                f.close()

        # get default semantic schema for PC inputs
        future = self._flai_sdk_executor.submit(
            self.SemanticDefinitionSchemasModel().get_semantic_definitions,
            semantic_definition_schema_id = '12e72edc-811d-4677-8bb4-67eaf0e53fc5'  # it should be 'the generic' ASPRS schema
        )

        # updating labels
        self.label_wasCLIFound.setText('<b>Flai CLI Detected</b>. Processing tab unlocked.')
        self.label_aboutCLIVersion.setText(
            f'You have Flai CLI version '
            f'<span style="color: #498FFF;"><b>{self._cli_version}</b></span>'
            f' installed.'
            )
        filtered_org_name = re.sub(r"[\"\'\`]", "", self._org_name)    # strip out any ASCII single-quote, double-quote or backtick characters
        self.label_aboutYourOrganization.setText(
            f'You are currently logged in organization: '
            f'<span style="color: #498FFF;"><b>{filtered_org_name}</b></span>'
        )

        # wait for slow call to finish
        try:
            semantic_schema = future.result(timeout=TIMEOUT_TIME_IN_SECONDS)
            self._default_input_pc_semantic_schema = self._parse_semantic_schema(semantic_schema)
        except concurrent.futures.TimeoutError:
            # still running after TIMEOUT_TIME_IN_SECONDS s â†’ cancel & fallback
            future.cancel()
            self.show_generic_sdk_warning(message=TIMEOUT_ERROR)
            return
        except Exception as e:
            self.show_generic_sdk_warning(message=GENERAL_ERROR + f"{str(e)}")
            return

        # disabling buttons
        self.pshBtn_findFile.setEnabled(False)      # user "logged in", we do not need this two enabled
        self.pshBtn_downloadFile.setEnabled(False)

        # updating "Processing" tab
        self.tab_processing.setEnabled(True)        # user "logged in", enable it
        self._clean_variables_of_processing_tab()
        self._disable_buttons_and_clean_warnings_on_processing_tab()
        self._populate_flow_template_combobox()


    def _populate_flow_template_combobox(self):
        future = self._flai_sdk_executor.submit(
            self.FlaiFlowTemplates().get_flow_templates    # if you get stuck here, you are missing $HOME/.flai file
        )

        # wait for slow call to finish
        try:
            flow_templates = future.result(timeout=TIMEOUT_TIME_IN_SECONDS)
        except concurrent.futures.TimeoutError:
            # still running after TIMEOUT_TIME_IN_SECONDS â†’ cancel & fallback
            future.cancel()
            self.show_generic_sdk_warning(message=TIMEOUT_ERROR)
            return
        except Exception as e:
            self.show_generic_sdk_warning(message=GENERAL_ERROR + f"{str(e)}")
            return

        self.flow_templates_cmbBx_mapping.update({
            i+1: {
                'title': entry['title'],
                'id':    entry['id']
            }
            for i, entry in enumerate(flow_templates)
        })

        current_index = self.cmbBx_flowTemplate.currentIndex()
        self.cmbBx_flowTemplate.clear()
        
        for entry in self.flow_templates_cmbBx_mapping.values():
            self.cmbBx_flowTemplate.addItem(entry['title'])

        self.cmbBx_flowTemplate.setCurrentIndex(current_index)


    def _get_cli_version(self, cli_path):
        issue = ''
        tag = ''
        
        # finding _internal folder
        base_dir = os.path.dirname(cli_path)
        internal_dir = os.path.join(base_dir, "_internal")

        if not os.path.isdir(internal_dir):
            issue = f"Could not find folder _internal on path:\n{base_dir}"
            return tag, issue

        # look for config.env
        config_path = os.path.join(internal_dir, "config.env")
        if not os.path.isfile(config_path):
            issue = f"Could not find file config.env on path:\n{internal_dir}"
            return tag, issue

        # parsing out BITBUCKET_TAG=
        pattern = re.compile(r"^BITBUCKET_TAG=(.+)$")
        try:
            with open(config_path, "r") as cfg:
                for line in cfg:
                    m = pattern.match(line.strip())
                    if m:
                        tag = m.group(1)
                        break
        except Exception as e:
            issue =  f"Failed to read {config_path}:\n{e}"
            return tag, issue

        if not tag:
            issue =  f"No line beginning with BITBUCKET_TAG= found in config.env on path:\n{config_path}"
            return tag, issue

        return tag, issue


    def _get_cli_link(self):
        msg = QtWidgets.QMessageBox(self)
        msg.setIcon(QtWidgets.QMessageBox.Information)
        msg.setWindowTitle("Instructions")
        msg.setText(
            "After clicking OK button below, plugin will open file explorer and two tabs.\n\n"
            "One tab will have documentation on how to install CLI while the other one will open a page where CLI can be download.\n\n"
            "Plugin will also open default folder where CLI can be saved by using system file explorer. Once download is finished you can copy your CLI to this folder."
        )

        # default setting for QMessageBox was buggy, even if user clicked on Close (x) button this line "if ret == QtWidgets.QMessageBox.Ok" was True
        # Give it both OK and Cancelâ€¦
        msg.setStandardButtons(
            QtWidgets.QMessageBox.Ok |
            QtWidgets.QMessageBox.Cancel
        )
        # â€¦but hide the Cancel button so the user only sees â€œOKâ€
        msg.button(QtWidgets.QMessageBox.Cancel).setVisible(False)

        msg.setFont(self._font_inside_msg_box)
        for btn in msg.buttons():
            btn.setFont(self._font_inside_msg_box)

        ret = msg.exec_()
        if ret == QtWidgets.QMessageBox.Ok:
            # on Windows this should call Explorer, on macOS â€œopenâ€, on Linux â€œxdg-openâ€
            QDesktopServices.openUrl(
                QUrl.fromLocalFile(self._default_cli_dir)
            )
            time.sleep(.5)  # to be more smooth

            # hard-coded URL
            webbrowser.open("https://app.flai.ai/#/admin/pages:cli-dashboard/?utm_source=qgis&utm_medium=qgis-flai-plugin&utm_campaigne=flai-pages:cli-dashboard", new=1)   # open new window
            time.sleep(.2)  # to be more smooth
            webbrowser.open("https://docs.flai.ai/?utm_source=qgis&utm_medium=qgis-flai-plugin&utm_campaigne=flai-docs.flai.ai#/command-line-interface", new=2)             # open new tab


    def get_show_welcome_warning_value(self): 
        return self._is_show_welcome_warning_disabled


    def set_show_welcome_warning_value(self, value):
        """Setter method to set the show_welcome_warning_value."""
        self._is_show_welcome_warning_disabled = value
        # self._loading_and_setting_show_welcome_warning_from_settings()
        self.value_changed_for_welcome_warning.emit(self._is_show_welcome_warning_disabled)  # Emit the signal to notify listeners


    def _loading_and_setting_show_welcome_warning_from_settings(self):
        if self._settings.contains('is-welcome-warning-disabled'):
            int_value = int(self._settings.value('is-welcome-warning-disabled'))
            self._is_show_welcome_warning_disabled = bool(int_value)
        else:
            self._settings.setValue('is-welcome-warning-disabled', int(self._is_show_welcome_warning_disabled))


    def _parse_semantic_schema(self, schema: dict, fields_to_keep=[SEMANTIC_DEFINITION_VALUE_FIELD, SEMANTIC_DEFINITION_LABEL_FIELD, SEMANTIC_DEFINITION_COLOR_FIELD]):
        final_variable = []

        for semantic_definition in schema.values():
            tmp = {}
            
            for field in fields_to_keep:
                tmp[field] = semantic_definition[field]

            final_variable.append(tmp)

        return final_variable
